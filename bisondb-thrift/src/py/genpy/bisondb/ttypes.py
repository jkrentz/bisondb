#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:utf8strings
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None



class Value:
  """
  Attributes:
   - data
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'data', None, None, ), # 1
  )

  def __init__(self, data=None,):
    self.data = data

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.data = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Value')
    if self.data is not None:
      oprot.writeFieldBegin('data', TType.STRING, 1)
      oprot.writeString(self.data)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LoadingStatus:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LoadingStatus')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ReadyStatus:
  """
  Attributes:
   - update_status
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'update_status', (LoadingStatus, LoadingStatus.thrift_spec), None, ), # 1
  )

  def __init__(self, update_status=None,):
    self.update_status = update_status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.update_status = LoadingStatus()
          self.update_status.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ReadyStatus')
    if self.update_status is not None:
      oprot.writeFieldBegin('update_status', TType.STRUCT, 1)
      self.update_status.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class FailedStatus:
  """
  Attributes:
   - error_message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'error_message', None, None, ), # 1
  )

  def __init__(self, error_message=None,):
    self.error_message = error_message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.error_message = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('FailedStatus')
    if self.error_message is not None:
      oprot.writeFieldBegin('error_message', TType.STRING, 1)
      oprot.writeString(self.error_message.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ShutdownStatus:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ShutdownStatus')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DomainStatus:
  """
  Attributes:
   - ready
   - loading
   - failed
   - shutdown
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ready', (ReadyStatus, ReadyStatus.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'loading', (LoadingStatus, LoadingStatus.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'failed', (FailedStatus, FailedStatus.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'shutdown', (ShutdownStatus, ShutdownStatus.thrift_spec), None, ), # 4
  )

  def __init__(self, ready=None, loading=None, failed=None, shutdown=None,):
    self.ready = ready
    self.loading = loading
    self.failed = failed
    self.shutdown = shutdown

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ready = ReadyStatus()
          self.ready.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.loading = LoadingStatus()
          self.loading.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.failed = FailedStatus()
          self.failed.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.shutdown = ShutdownStatus()
          self.shutdown.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DomainStatus')
    if self.ready is not None:
      oprot.writeFieldBegin('ready', TType.STRUCT, 1)
      self.ready.write(oprot)
      oprot.writeFieldEnd()
    if self.loading is not None:
      oprot.writeFieldBegin('loading', TType.STRUCT, 2)
      self.loading.write(oprot)
      oprot.writeFieldEnd()
    if self.failed is not None:
      oprot.writeFieldBegin('failed', TType.STRUCT, 3)
      self.failed.write(oprot)
      oprot.writeFieldEnd()
    if self.shutdown is not None:
      oprot.writeFieldBegin('shutdown', TType.STRUCT, 4)
      self.shutdown.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Status:
  """
  Attributes:
   - domain_statuses
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'domain_statuses', (TType.STRING,None,TType.STRUCT,(DomainStatus, DomainStatus.thrift_spec)), None, ), # 1
  )

  def __init__(self, domain_statuses=None,):
    self.domain_statuses = domain_statuses

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.domain_statuses = {}
          (_ktype1, _vtype2, _size0 ) = iprot.readMapBegin()
          for _i4 in xrange(_size0):
            _key5 = iprot.readString().decode('utf-8')
            _val6 = DomainStatus()
            _val6.read(iprot)
            self.domain_statuses[_key5] = _val6
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Status')
    if self.domain_statuses is not None:
      oprot.writeFieldBegin('domain_statuses', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.domain_statuses))
      for kiter7,viter8 in self.domain_statuses.items():
        oprot.writeString(kiter7.encode('utf-8'))
        viter8.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.domain_statuses is None:
      raise TProtocol.TProtocolException(message='Required field domain_statuses is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DomainSpec:
  """
  Attributes:
   - num_shards
   - coordinator
   - shard_scheme
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'num_shards', None, None, ), # 1
    (2, TType.STRING, 'coordinator', None, None, ), # 2
    (3, TType.STRING, 'shard_scheme', None, None, ), # 3
  )

  def __init__(self, num_shards=None, coordinator=None, shard_scheme=None,):
    self.num_shards = num_shards
    self.coordinator = coordinator
    self.shard_scheme = shard_scheme

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.num_shards = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.coordinator = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.shard_scheme = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DomainSpec')
    if self.num_shards is not None:
      oprot.writeFieldBegin('num_shards', TType.I32, 1)
      oprot.writeI32(self.num_shards)
      oprot.writeFieldEnd()
    if self.coordinator is not None:
      oprot.writeFieldBegin('coordinator', TType.STRING, 2)
      oprot.writeString(self.coordinator.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.shard_scheme is not None:
      oprot.writeFieldBegin('shard_scheme', TType.STRING, 3)
      oprot.writeString(self.shard_scheme.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.num_shards is None:
      raise TProtocol.TProtocolException(message='Required field num_shards is unset!')
    if self.coordinator is None:
      raise TProtocol.TProtocolException(message='Required field coordinator is unset!')
    if self.shard_scheme is None:
      raise TProtocol.TProtocolException(message='Required field shard_scheme is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DomainMetaData:
  """
  Attributes:
   - remote_version
   - local_version
   - shard_set
   - domain_spec
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'remote_version', None, None, ), # 1
    (2, TType.I64, 'local_version', None, None, ), # 2
    (3, TType.SET, 'shard_set', (TType.I64,None), None, ), # 3
    (4, TType.STRUCT, 'domain_spec', (DomainSpec, DomainSpec.thrift_spec), None, ), # 4
  )

  def __init__(self, remote_version=None, local_version=None, shard_set=None, domain_spec=None,):
    self.remote_version = remote_version
    self.local_version = local_version
    self.shard_set = shard_set
    self.domain_spec = domain_spec

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.remote_version = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.local_version = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.SET:
          self.shard_set = set()
          (_etype12, _size9) = iprot.readSetBegin()
          for _i13 in xrange(_size9):
            _elem14 = iprot.readI64();
            self.shard_set.add(_elem14)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.domain_spec = DomainSpec()
          self.domain_spec.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DomainMetaData')
    if self.remote_version is not None:
      oprot.writeFieldBegin('remote_version', TType.I64, 1)
      oprot.writeI64(self.remote_version)
      oprot.writeFieldEnd()
    if self.local_version is not None:
      oprot.writeFieldBegin('local_version', TType.I64, 2)
      oprot.writeI64(self.local_version)
      oprot.writeFieldEnd()
    if self.shard_set is not None:
      oprot.writeFieldBegin('shard_set', TType.SET, 3)
      oprot.writeSetBegin(TType.I64, len(self.shard_set))
      for iter15 in self.shard_set:
        oprot.writeI64(iter15)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.domain_spec is not None:
      oprot.writeFieldBegin('domain_spec', TType.STRUCT, 4)
      self.domain_spec.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.remote_version is None:
      raise TProtocol.TProtocolException(message='Required field remote_version is unset!')
    if self.local_version is None:
      raise TProtocol.TProtocolException(message='Required field local_version is unset!')
    if self.shard_set is None:
      raise TProtocol.TProtocolException(message='Required field shard_set is unset!')
    if self.domain_spec is None:
      raise TProtocol.TProtocolException(message='Required field domain_spec is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MetaData:
  """
  Attributes:
   - domain_metadatas
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'domain_metadatas', (TType.STRING,None,TType.STRUCT,(DomainMetaData, DomainMetaData.thrift_spec)), None, ), # 1
  )

  def __init__(self, domain_metadatas=None,):
    self.domain_metadatas = domain_metadatas

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.domain_metadatas = {}
          (_ktype17, _vtype18, _size16 ) = iprot.readMapBegin()
          for _i20 in xrange(_size16):
            _key21 = iprot.readString().decode('utf-8')
            _val22 = DomainMetaData()
            _val22.read(iprot)
            self.domain_metadatas[_key21] = _val22
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MetaData')
    if self.domain_metadatas is not None:
      oprot.writeFieldBegin('domain_metadatas', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.domain_metadatas))
      for kiter23,viter24 in self.domain_metadatas.items():
        oprot.writeString(kiter23.encode('utf-8'))
        viter24.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.domain_metadatas is None:
      raise TProtocol.TProtocolException(message='Required field domain_metadatas is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DomainNotFoundException(TException):
  """
  Attributes:
   - domain
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'domain', None, None, ), # 1
  )

  def __init__(self, domain=None,):
    self.domain = domain

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.domain = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DomainNotFoundException')
    if self.domain is not None:
      oprot.writeFieldBegin('domain', TType.STRING, 1)
      oprot.writeString(self.domain.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.domain is None:
      raise TProtocol.TProtocolException(message='Required field domain is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DomainNotLoadedException(TException):
  """
  Attributes:
   - domain
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'domain', None, None, ), # 1
  )

  def __init__(self, domain=None,):
    self.domain = domain

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.domain = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DomainNotLoadedException')
    if self.domain is not None:
      oprot.writeFieldBegin('domain', TType.STRING, 1)
      oprot.writeString(self.domain.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.domain is None:
      raise TProtocol.TProtocolException(message='Required field domain is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class HostsDownException(TException):
  """
  Attributes:
   - hosts
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'hosts', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, hosts=None,):
    self.hosts = hosts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.hosts = []
          (_etype28, _size25) = iprot.readListBegin()
          for _i29 in xrange(_size25):
            _elem30 = iprot.readString().decode('utf-8')
            self.hosts.append(_elem30)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('HostsDownException')
    if self.hosts is not None:
      oprot.writeFieldBegin('hosts', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.hosts))
      for iter31 in self.hosts:
        oprot.writeString(iter31.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.hosts is None:
      raise TProtocol.TProtocolException(message='Required field hosts is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidConfigurationException(TException):
  """
  Attributes:
   - mismatched_domains
   - port_changed
   - hosts_changed
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'mismatched_domains', (TType.STRING,None), None, ), # 1
    (2, TType.BOOL, 'port_changed', None, None, ), # 2
    (3, TType.BOOL, 'hosts_changed', None, None, ), # 3
  )

  def __init__(self, mismatched_domains=None, port_changed=None, hosts_changed=None,):
    self.mismatched_domains = mismatched_domains
    self.port_changed = port_changed
    self.hosts_changed = hosts_changed

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.mismatched_domains = []
          (_etype35, _size32) = iprot.readListBegin()
          for _i36 in xrange(_size32):
            _elem37 = iprot.readString().decode('utf-8')
            self.mismatched_domains.append(_elem37)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.port_changed = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.hosts_changed = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidConfigurationException')
    if self.mismatched_domains is not None:
      oprot.writeFieldBegin('mismatched_domains', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.mismatched_domains))
      for iter38 in self.mismatched_domains:
        oprot.writeString(iter38.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.port_changed is not None:
      oprot.writeFieldBegin('port_changed', TType.BOOL, 2)
      oprot.writeBool(self.port_changed)
      oprot.writeFieldEnd()
    if self.hosts_changed is not None:
      oprot.writeFieldBegin('hosts_changed', TType.BOOL, 3)
      oprot.writeBool(self.hosts_changed)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.mismatched_domains is None:
      raise TProtocol.TProtocolException(message='Required field mismatched_domains is unset!')
    if self.port_changed is None:
      raise TProtocol.TProtocolException(message='Required field port_changed is unset!')
    if self.hosts_changed is None:
      raise TProtocol.TProtocolException(message='Required field hosts_changed is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WrongHostException(TException):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WrongHostException')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
